<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8"/>
<title>åœ–å­—è£½ä½œå°å·¥å…·</title>
<style>

  body {
  background-color: #fff; 
  font-family: 'Segoe UI', sans-serif;
  color: #333;
}
  canvas {
  border: 1px solid #aaa;
  background-color: #fff; /* ç™½åº• */
  box-shadow: 0 2px 6px rgba(0,0,0,0.05); /* è¼•å¾®é™°å½±è®“ç•«å¸ƒæµ®èµ·ä¾† */
  display: block;
  margin-bottom: 10px;
  border-radius: 4px; /* åœ“è§’å¯é¸ */
  cursor: default;
}
  .char-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; flex-wrap: wrap; }
  textarea { width: 100%; height: 150px; margin-top: 20px; }
  .advanced-toggle { cursor: pointer; color: #007bff; text-decoration: underline; margin-left: 10px; }
  .advanced-section { display: none; margin-top: 5px; }
  .highlight {
    color: #b22222; /* æ·±ç´…è‰² */
  }
</style>
</head>
<body>
<h2>ğŸ§© åœ–å­—è£½ä½œå°å·¥å…·(By:å°D)</h2>
<input accept="image/*" id="imageUpload" type="file"/><br/><br/>

æ ¼å¯¬ <input id="gridW" style="width:60px;" type="number" value="40"/>
æ ¼é«˜ <input id="gridH" style="width:60px;" type="number" value="60"/>

ï½œæˆ–ä¾æ ¼æ•¸åˆ‡ï¼š
æ¬„æ•¸ <input id="gridCols" style="width:60px;" type="number" placeholder="æ¬„æ•¸" onchange="updateGridSizeFromCount()"/>
åˆ—æ•¸ <input id="gridRows" style="width:60px;" type="number" placeholder="åˆ—æ•¸" onchange="updateGridSizeFromCount()"/>

<button onclick="autoSlice(true)">è£½ä½œè£åˆ‡</button>
<button onclick="clearAllRects()">æ¸…é™¤è£åˆ‡</button>
<button onclick="centerAllOffsets()">ğŸ“Œ å±…ä¸­ã€ä¿®æ”¹å­—å…ƒå¯¬åº¦å¾Œè¦é»é€™è£¡é‡æ–°æ‰¾ä¸­å¿ƒé»ã€‘</button><br/><br/>
å­—å…ƒé †åºï¼š<br/><input id="charList" type="text" value="0123456789,."/><br/>

<canvas height="128" id="preview" width="512"></canvas>
<div id="currentEditLabel" style="font-weight:bold; margin-bottom:5px; color:#555;"></div>
<div id="charEditor"></div>
<span style="font-size: 16px; color: #666;">ï¼ˆå»ºè­°å¯¬æ•¸å€¼å„˜é‡èˆ‡å­—å…ƒå¯¬åº¦ç›¸åŒ,æ‰ä¸å®¹æ˜“å‡ºéŒ¯ï¼‰</span><br/>
<button onclick="addManualRect()">â• æ‰‹å‹•æ–°å¢æ ¼</button><br/>
é è¦½å­—ä¸²ï¼š<textarea id="previewString" style="width: 300px; height: 40px;" oninput="drawPreviewString()">123.45,678.9</textarea><br/>
<canvas id="stringPreview" width="512" height="210" style="border:1px solid #aaa; margin-top:10px;"></canvas>
<br/>
<button onclick="generateFNT()">ç”¢ç”Ÿ .fnt</button>
<button onclick="downloadFNT()">ä¸‹è¼‰ .fnt</button>
<span style="float: right;">
  <button onclick="downloadPlist()">ä¸‹è¼‰ .plist(éœ€è£½ä½œåœ–é›†æ™‚ä½¿ç”¨)</button>
</span>
<textarea id="outputFNT"></textarea>

<script>
const canvas = document.getElementById("preview");
const ctx = canvas.getContext("2d");
let image = new Image();
let imageFilename = "image.png";
let rects = [];
let dragIndex = -1, dragOffsetX = 0, dragOffsetY = 0;
let resizeMode = false;
let creatingNewRect = false;
let startX = 0, startY = 0;
let selectedIndex = -1;
let debounceTimer;
const SNAP_TOLERANCE = 8;
const RESIZE_HITBOX = 10;

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  dragIndex = rects.findIndex(r => x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h);
  selectedIndex = dragIndex;

//setTimeout(() => {
//  const el = document.getElementById(`charRow_${selectedIndex}`);
//  if (el) el.scrollIntoView({ behavior: "smooth", block: "center" });
//}, 10);

  if (dragIndex !== -1) {
    const r = rects[dragIndex];
    if (
      x >= r.x + r.w - RESIZE_HITBOX &&
      x <= r.x + r.w &&
      y >= r.y + r.h - RESIZE_HITBOX &&
      y <= r.y + r.h
    ) {
      resizeMode = true;
    } else {
      resizeMode = false;
      dragOffsetX = x - r.x;
      dragOffsetY = y - r.y;
    }
  } else {
    // ç©ºç™½è™•ï¼šé–‹å§‹æ‹‰å‡ºæ–°æ ¼å­
    creatingNewRect = true;
    startX = x;
    startY = y;
    rects.push({ x: x, y: y, w: 1, h: 1, adv: 1, xoff: 0, yoff: 0 });
    dragIndex = rects.length - 1;
  }
});

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  if (dragIndex !== -1) {
    const r = rects[dragIndex];

    if (creatingNewRect) {
      let rawX = Math.min(startX, mouseX);
      let rawY = Math.min(startY, mouseY);
      let newW = Math.max(1, Math.abs(mouseX - startX));
      let newH = Math.max(1, Math.abs(mouseY - startY));
      let snapX = rawX;
      let snapY = rawY;

      for (let i = 0; i < rects.length - 1; i++) {
        const other = rects[i];
        if (Math.abs(rawX - other.x) < SNAP_TOLERANCE) snapX = other.x;
        if (Math.abs(rawX + newW - other.x) < SNAP_TOLERANCE) snapX = other.x - newW;
        if (Math.abs(rawX - (other.x + other.w)) < SNAP_TOLERANCE) snapX = other.x + other.w;

        if (Math.abs(rawY - other.y) < SNAP_TOLERANCE) snapY = other.y;
        if (Math.abs(rawY + newH - other.y) < SNAP_TOLERANCE) snapY = other.y - newH;
        if (Math.abs(rawY - (other.y + other.h)) < SNAP_TOLERANCE) snapY = other.y + other.h;
      }

      r.x = snapX;
      r.y = snapY;
      r.w = newW;
      r.h = newH;
      r.adv = r.w;
    } else if (resizeMode) {
      r.w = Math.max(1, mouseX - r.x);
      r.h = Math.max(1, mouseY - r.y);

      // åŒæ­¥æ›´æ–° adv å’Œ xoffï¼Œè®“è—æ¡†ä¹Ÿè·Ÿè‘—æ‹‰ä¼¸
      r.adv = r.w;
      r.xoff = 0; // è®“åç§»å›æ­¸èµ·é»ï¼ˆè—æ¡†å·¦é‚Šå°é½Šæ ¼å­èµ·é»ï¼‰
      
      // r.xoff = Math.floor((r.adv - r.w) / 2);
} else {
      let newX = mouseX - dragOffsetX;
      let newY = mouseY - dragOffsetY;
      let snapX = newX;
      let snapY = newY;

      for (let i = 0; i < rects.length; i++) {
        if (i === dragIndex) continue;
        const other = rects[i];

        if (Math.abs(newX - other.x) < SNAP_TOLERANCE) snapX = other.x;
        if (Math.abs(newX - (other.x + other.w)) < SNAP_TOLERANCE) snapX = other.x + other.w;
        if (Math.abs(newX + r.w - other.x) < SNAP_TOLERANCE) snapX = other.x - r.w;

        if (Math.abs(newY - other.y) < SNAP_TOLERANCE) snapY = other.y;
        if (Math.abs(newY - (other.y + other.h)) < SNAP_TOLERANCE) snapY = other.y + other.h;
        if (Math.abs(newY + r.h - other.y) < SNAP_TOLERANCE) snapY = other.y - r.h;
      }

      r.x = snapX;
      r.y = snapY;
    }

    drawAllRects();
  }

  let hoverResize = false;
  for (let i = 0; i < rects.length; i++) {
    const r = rects[i];
    const rx = r.x + r.w;
    const ry = r.y + r.h;
    if (
      mouseX >= rx - RESIZE_HITBOX &&
      mouseX <= rx &&
      mouseY >= ry - RESIZE_HITBOX &&
      mouseY <= ry
    ) {
      hoverResize = true;
      break;
    }
  }
  canvas.style.cursor = hoverResize ? "nwse-resize" : "default";
});


canvas.addEventListener("mouseup", () => {
  if (creatingNewRect) {
    const r = rects[rects.length - 1];
    if (r.w < 4 || r.h < 4) {
      rects.pop(); // åˆªé™¤å¤ªå°çš„æ ¼å­
    }
  }
  dragIndex = -1;
  resizeMode = false;
  creatingNewRect = false;
  updateCharEditor();
  drawAllRects();
});

canvas.addEventListener("mouseleave", () => dragIndex = -1);

function drawAllRects() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (image.src) ctx.drawImage(image, 0, 0);


    // é¡¯ç¤ºé¸å–ä¸­çš„æ ¼å­ç·¨è™Ÿ
    rects.forEach((r, i) => {
  ctx.strokeStyle = "gold";
  ctx.strokeRect(r.x, r.y, r.w, r.h);

  // æ¯æ ¼éƒ½æ¨™ç·¨è™Ÿï¼ˆé»‘è‰²ï¼‰
  //ctx.fillStyle = "black";
  //ctx.font = "12px sans-serif";
  //ctx.fillText(`#${i}`, r.x + 2, r.y + 14);

  // é¸ä¸­çš„æ ¼å­ç”¨ç´…åº•æ¡†æ¨™ç¤ºç·¨è™Ÿ
  if (i === selectedIndex) {
      const label = `#${i}`;
      ctx.font = "bold 14px sans-serif";
      const textWidth = ctx.measureText(label).width;
      const textX = r.x + 2;
      const textY = r.y + 16;

      // ç´…è‰²åº•
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      ctx.fillRect(textX - 2, textY - 12, textWidth + 4, 16);

      // ç™½å­—
      ctx.fillStyle = "rgba(255, 255, 255, 1)";
      ctx.fillText(label, textX, textY);
}

  // æ°´å¹³åç§»ç·šï¼šå·¦ï¼ˆè—è‰²ï¼‰
  ctx.strokeStyle = "lightblue";
  ctx.beginPath();
  ctx.moveTo(r.x + r.xoff, r.y);
  ctx.lineTo(r.x + r.xoff, r.y + r.h);
  ctx.stroke();

  // æ°´å¹³åç§»ç·šï¼šå³ï¼ˆyoffï¼‰
    ctx.beginPath();
    ctx.moveTo(r.x + r.xoff + r.adv, r.y);
    ctx.lineTo(r.x + r.xoff + r.adv, r.y + r.h);
    ctx.stroke();

  // å‚ç›´åç§»ç·šï¼ˆyoffï¼‰
    ctx.beginPath();
    ctx.moveTo(r.x, r.y + r.yoff);
    ctx.lineTo(r.x + r.w, r.y + r.yoff);
    ctx.stroke();
  });
  drawPreviewString();
}

function clearAllRects() {
  if (confirm("ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è£åˆ‡æ ¼å­å—ï¼Ÿ")) {
    rects = [];
    selectedIndex = -1;
    updateCharEditor();
    drawAllRects();
  }
}

function drawPreviewString() {
  const str = document.getElementById("previewString").value;
  const canvas2 = document.getElementById("stringPreview");
  const ctx2 = canvas2.getContext("2d");
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

  const lines = str.split("\n");
  const maxHeight = Math.max(...rects.map(r => r.h)) || 1;
  const lineHeight = maxHeight + 10;

  // è¨ˆç®—ç¸½é«˜åº¦ã€ç¸½å¯¬åº¦
  let maxLineWidth = 0;
  for (let line of lines) {
    let lineWidth = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      lineWidth += r.adv || r.w;
    }
    if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
  }
  const totalHeight = lineHeight * lines.length;

  // æŒ‰ç…§æ¯”ä¾‹ç¸®æ”¾
  const scaleX = canvas2.width / maxLineWidth;
  const scaleY = canvas2.height / totalHeight;
  const scale = Math.min(scaleX, scaleY, 1);

  let yBase = 0;
  for (let line of lines) {
    let x = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      const drawX = x + (r.xoff || 0) * scale;
      const drawY = yBase + (r.yoff || 0) * scale;
      ctx2.drawImage(image, r.x, r.y, r.w, r.h, drawX, drawY, r.w * scale, r.h * scale);
      x += (r.adv || r.w) * scale;
    }
    yBase += lineHeight * scale;
  }
}
  

function updateGridSizeFromCount() {
  const cols = parseInt(document.getElementById("gridCols").value);
  const rows = parseInt(document.getElementById("gridRows").value);
  const MAX_CELLS = 50;

  if (isNaN(cols) || isNaN(rows) || cols <= 0 || rows <= 0) {
    alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ¬„æ•¸èˆ‡åˆ—æ•¸");
    return;
  }

  if (cols * rows > MAX_CELLS) {
    alert(`æ ¼å­ç¸½æ•¸ (${cols * rows}) è¶…éä¸Šé™ ${MAX_CELLS}ï¼Œè«‹æ¸›å°‘æ¬„æ•¸æˆ–åˆ—æ•¸`);
    return;
  }

  const w = Math.floor(canvas.width / cols);
  const h = Math.floor(canvas.height / rows);
  document.getElementById("gridW").value = w;
  document.getElementById("gridH").value = h;

  autoSlice(true);
}


function autoSlice(clearOld = true) {
  const w = parseInt(document.getElementById("gridW").value);
  const h = parseInt(document.getElementById("gridH").value);
  const cols = Math.floor(canvas.width / w);
  const rows = Math.floor(canvas.height / h);
  if (clearOld) rects = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      rects.push({ x: x * w, y: y * h, w: w, h: h, adv: w, xoff: 0, yoff: 0 });
    }
  }
  updateCharEditor();
  drawAllRects();
}

function addManualRect() {
  rects.push({ x: 0, y: 0, w: 32, h: 32, adv: 32, xoff: 0, yoff: 0 });
  updateCharEditor();
  drawAllRects();
}

function updateCharEditor() {
  const container = document.getElementById("charEditor");
  const label = document.getElementById("currentEditLabel");
  container.innerHTML = "";

  if (selectedIndex >= 0 && rects[selectedIndex]) {
    label.textContent = `ğŸ”§ æ­£åœ¨ç·¨è¼¯æ ¼å­ #${selectedIndex}`;
  } else {
    label.textContent = "";
  }

  rects.forEach((r, i) => {
    const row = document.createElement("div");
    row.className = "char-row" + (i === selectedIndex ? " highlight" : "");
    row.id = `charRow_${i}`;
    row.innerHTML = `
      #${i}
      x:<input id="x_input_${i}" type="number" value="${r.x}" 
         oninput="updateVal(${i}), 'x', this.value)" style="width:60px;">

      y:<input id="y_input_${i}" type="number" value="${r.y}" 
         oninput="updateVal(${i}), 'y', this.value)" style="width:60px;">

      å¯¬ã€æ©˜æ¡†ã€:<input id="w_input_${i}" type="number" value="${r.w}" oninput="updateVal(${i}), 'w', this.value)" style="width:60px;">

      é«˜:<input id="h_input_${i}" type="number" value="${r.h}" oninput="updateVal(${i}), 'h', this.value)" style="width:60px;">

      å­—å…ƒå¯¬åº¦ã€è—æ¡†ã€:<input id="adv_input_${i}" type="number" value="${r.adv}" 
  oninput="updateVal(${i}), 'adv', this.value)" style="width:60px;">


      <button onclick="confirmAdv(${i})">ç¢ºèª</button>
      <button onclick="removeRect(${i})" style="color:red;">âŒ</button>
      <span class="advanced-toggle" onclick="toggleAdvanced(${i})">é€²éšè¨­å®š â–¼</span>
      <div class="advanced-section" id="adv_section_${i}">
        æ°´å¹³åç§»:<input id="xoff_input_${i}" type="number" value="${r.xoff}" 
        oninput="updateVal(${i}), 'xoff', this.value)" style="width:60px;">
        å‚ç›´åç§»:<input id="yoff_input_${i}" type="number" value="${r.yoff}" 
        oninput="updateVal(${i}), 'yoff', this.value)" style="width:60px;">

        <button onclick="confirmOffset(${i})">ç¢ºèªä½ç§»</button>
      </div>
    `;
    container.appendChild(row);
  });
}

function setSelected(i) {
  if (selectedIndex === i) return; // è‹¥å·²é¸ä¸­å°±ä¸å‹•ä½œ
  selectedIndex = i;
  drawAllRects();

  // åªæ›´æ–°é«˜äº®ï¼Œä¸å‘¼å« updateCharEditor
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });
}


function removeRect(index) {
  rects.splice(index, 1);
  updateCharEditor();
  drawAllRects();
}

function toggleAdvanced(i) {
  const sec = document.getElementById(`adv_section_${i}`);
  sec.style.display = sec.style.display === 'block' ? 'none' : 'block';
}

function updateVal(i, prop, val) {
  rects[i][prop] = parseInt(val);
  selectedIndex = i;
  drawAllRects();

  // æ›´æ–° highlight æ¨£å¼
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });

  // è‡ªå‹•æ²å‹•åˆ°å°æ‡‰é …ç›®ï¼ˆé¿å…è¼¸å…¥æ™‚ä¸çŸ¥é“å°æ‡‰å“ªæ ¼ï¼‰
  const el = document.getElementById(`charRow_${selectedIndex}`);
  if (el) {
    el.scrollIntoView({ behavior: "smooth", block: "center" });
  }

  // å»¶é²æ•´é«”æ›´æ–°ï¼Œé˜²æ­¢ lag
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    updateCharEditor();
  }, 200);
}

function confirmAdv(i) {
  const rect = rects[i];
  const get = id => parseFloat(document.getElementById(`${id}_input_${i}`).value);

  const x = get("x");
  const y = get("y");
  const w = get("w");
  const h = get("h");
  const adv = get("adv");

  if (!isNaN(x)) rect.x = x;
  if (!isNaN(y)) rect.y = y;
  if (!isNaN(w)) rect.w = w;
  if (!isNaN(h)) rect.h = h;
  if (!isNaN(adv)) rect.adv = adv;

  drawAllRects();
}


function confirmOffset(i) {
  const xoff = parseInt(document.getElementById(`xoff_input_${i}`).value);
  const yoff = parseInt(document.getElementById(`yoff_input_${i}`).value);
  if (!isNaN(xoff)) rects[i].xoff = xoff;
  if (!isNaN(yoff)) rects[i].yoff = yoff;
  drawAllRects();
}

function centerAllOffsets() {
  const lineHeight = Math.max(...rects.map(r => r.h));
  rects.forEach((r) => {
    r.xoff = Math.floor((r.adv - r.w) / 2);
    r.yoff = Math.floor((lineHeight - r.h) / 2);
  });
  updateCharEditor();
  drawAllRects();
}

function generateFNT() {
  const chars = document.getElementById("charList").value;
  const lineHeight = Math.max(...rects.map(r => r.h));
  const base = lineHeight - 5;
  const fnt = [];
  fnt.push(`info face="bitmap" size=${lineHeight} bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1`);
  fnt.push(`common lineHeight=${lineHeight} base=${base} scaleW=${canvas.width} scaleH=${canvas.height} pages=1 packed=0`);
  fnt.push(`page id=0 file="${imageFilename}"`);
  fnt.push("chars count=" + chars.length);
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const id = c.charCodeAt(0);
    const xoff = r.xoff < 0 ? 0 : r.xoff;
    const yoff = r.yoff < 0 ? 0 : r.yoff;
    fnt.push(`char id=${id} x=${r.x} y=${r.y} width=${r.w} height=${r.h} xoffset=${xoff} yoffset=${yoff} xadvance=${r.adv} page=0 chnl=0`);
  });
  document.getElementById("outputFNT").value = fnt.join("\n");
}

function downloadFNT() {
  const blob = new Blob([document.getElementById("outputFNT").value], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".fnt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function downloadPlist() {
  const chars = document.getElementById("charList").value;
  const frames = {};
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const name = `${getSafeCharName(c)}.png`;
    frames[name] = {
      frame: `{{${r.x},${r.y}},{${r.w},${r.h}}}`,
      offset: `{0,0}`,
      rotated: false,
      sourceColorRect: `{{0,0},{${r.w},${r.h}}}`,
      sourceSize: `{${r.w},${r.h}}`
    };
  });

  const plistObj = {
    frames: frames,
    metadata: {
      format: 2,
      realTextureFileName: imageFilename,
      size: `{${canvas.width},${canvas.height}}`,
      smartupdate: "$TexturePacker:SmartUpdate$",
      textureFileName: imageFilename
    }
  };

  const content = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>frames</key>
  <dict>
${Object.entries(plistObj.frames).map(([name, f]) => `
    <key>${name}</key>
    <dict>
      <key>frame</key><string>${f.frame}</string>
      <key>offset</key><string>${f.offset}</string>
      <key>rotated</key><false/>
      <key>sourceColorRect</key><string>${f.sourceColorRect}</string>
      <key>sourceSize</key><string>${f.sourceSize}</string>
    </dict>`).join("\n")}
  </dict>
  <key>metadata</key>
  <dict>
    <key>format</key><integer>${plistObj.metadata.format}</integer>
    <key>realTextureFileName</key><string>${plistObj.metadata.realTextureFileName}</string>
    <key>size</key><string>${plistObj.metadata.size}</string>
    <key>smartupdate</key><string>${plistObj.metadata.smartupdate}</string>
    <key>textureFileName</key><string>${plistObj.metadata.textureFileName}</string>
  </dict>
</dict>
</plist>`;

  const blob = new Blob([content], { type: "text/xml" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".plist";
  a.click();
  URL.revokeObjectURL(a.href);
}

function getSafeCharName(c) {
  const map = {
    ",": "Comma",
    ".": "decimal",
    ":": "Colon",
    ";": "Semicolon",
    "+": "Plus",
    "-": "Minus",
    "/": "Slash",
    "!": "Exclamation",
    "?": "Question",
    "*": "Asterisk",
    " ": "Space",
    "\"": "Quote",
    "'": "Apostrophe",
    "\\": "Backslash",
    "|": "Pipe",
    "<": "LessThan",
    ">": "GreaterThan",
    "[": "LBracket",
    "]": "RBracket",
    "(": "LParen",
    ")": "RParen",
    "#": "Hash",
    "&": "Ampersand",
    "%": "Percent",
    "=": "Equal",
    "x": "x",
    "$": "Money"

  };

  // è‹¥æ˜¯ a~z æˆ– A~Z æˆ– æ•¸å­—ï¼Œç›´æ¥ä¿ç•™
  if (/^[a-zA-Z0-9]$/.test(c)) return c;
  return map[c] || `U${c.charCodeAt(0)}`; // fallbackï¼šä»¥ Unicode å‘½å
}



document.getElementById("imageUpload").addEventListener("change", e => {
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = evt => {
    image.onload = () => {
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      drawAllRects();
    };
    image.src = evt.target.result;
    imageFilename = file.name;
  };
  reader.readAsDataURL(file);
});
</script>
</body>
</html>
