<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8"/>
<title>圖字製作小工具</title>
<style>

  body {
  background-color: #fff; 
  font-family: 'Segoe UI', sans-serif;
  color: #333;
}
  canvas {
  border: 1px solid #aaa;
  background-color: #fff; /* 白底 */
  box-shadow: 0 2px 6px rgba(0,0,0,0.05); /* 輕微陰影讓畫布浮起來 */
  display: block;
  margin-bottom: 10px;
  border-radius: 4px; /* 圓角可選 */
  cursor: default;
}
  .char-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; flex-wrap: wrap; }
  textarea { width: 100%; height: 150px; margin-top: 20px; }
  .advanced-toggle { cursor: pointer; color: #007bff; text-decoration: underline; margin-left: 10px; }
  .advanced-section { display: none; margin-top: 5px; }
  .highlight {
    color: #b22222; /* 深紅色 */
  }
</style>
</head>
<body>
<h2>🧩 圖字製作小工具(By:小D)</h2>
<input accept="image/*" id="imageUpload" type="file"/><br/><br/>

格寬 <input id="gridW" style="width:60px;" type="number" value="40"/>
格高 <input id="gridH" style="width:60px;" type="number" value="60"/>

｜或依格數切：
欄數 <input id="gridCols" style="width:60px;" type="number" placeholder="欄數" onchange="updateGridSizeFromCount()"/>
列數 <input id="gridRows" style="width:60px;" type="number" placeholder="列數" onchange="updateGridSizeFromCount()"/>

<button onclick="autoSlice(true)">製作裁切</button>
<button onclick="clearAllRects()">清除裁切</button>
<button onclick="centerAllOffsets()">📌 居中【修改字元寬度後要點這裡重新找中心點】</button><br/><br/>
字元順序：<br/><input id="charList" type="text" value="0123456789,."/><br/>

<canvas height="128" id="preview" width="512"></canvas>
<div id="currentEditLabel" style="font-weight:bold; margin-bottom:5px; color:#555;"></div>
<div id="charEditor"></div>
<span style="font-size: 16px; color: #666;">（建議寬數值儘量與字元寬度相同,才不容易出錯）</span><br/>
<button onclick="addManualRect()">➕ 手動新增格</button><br/>
預覽字串：<textarea id="previewString" style="width: 300px; height: 40px;" oninput="drawPreviewString()">123.45,678.9</textarea><br/>
<canvas id="stringPreview" width="512" height="210" style="border:1px solid #aaa; margin-top:10px;"></canvas>
<br/>
<button onclick="generateFNT()">產生 .fnt</button>
<button onclick="downloadFNT()">下載 .fnt</button>
<span style="float: right;">
  <button onclick="downloadPlist()">下載 .plist(需製作圖集時使用)</button>
</span>
<textarea id="outputFNT"></textarea>

<script>
const canvas = document.getElementById("preview");
const ctx = canvas.getContext("2d");
let image = new Image();
let imageFilename = "image.png";
let rects = [];
let dragIndex = -1, dragOffsetX = 0, dragOffsetY = 0;
let resizeMode = false;
let creatingNewRect = false;
let startX = 0, startY = 0;
let selectedIndex = -1;
let debounceTimer;
const SNAP_TOLERANCE = 8;
const RESIZE_HITBOX = 10;

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  dragIndex = rects.findIndex(r => x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h);
  selectedIndex = dragIndex;

//setTimeout(() => {
//  const el = document.getElementById(`charRow_${selectedIndex}`);
//  if (el) el.scrollIntoView({ behavior: "smooth", block: "center" });
//}, 10);

  if (dragIndex !== -1) {
    const r = rects[dragIndex];
    if (
      x >= r.x + r.w - RESIZE_HITBOX &&
      x <= r.x + r.w &&
      y >= r.y + r.h - RESIZE_HITBOX &&
      y <= r.y + r.h
    ) {
      resizeMode = true;
    } else {
      resizeMode = false;
      dragOffsetX = x - r.x;
      dragOffsetY = y - r.y;
    }
  } else {
    // 空白處：開始拉出新格子
    creatingNewRect = true;
    startX = x;
    startY = y;
    rects.push({ x: x, y: y, w: 1, h: 1, adv: 1, xoff: 0, yoff: 0 });
    dragIndex = rects.length - 1;
  }
});

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  if (dragIndex !== -1) {
    const r = rects[dragIndex];

    if (creatingNewRect) {
      let rawX = Math.min(startX, mouseX);
      let rawY = Math.min(startY, mouseY);
      let newW = Math.max(1, Math.abs(mouseX - startX));
      let newH = Math.max(1, Math.abs(mouseY - startY));
      let snapX = rawX;
      let snapY = rawY;

      for (let i = 0; i < rects.length - 1; i++) {
        const other = rects[i];
        if (Math.abs(rawX - other.x) < SNAP_TOLERANCE) snapX = other.x;
        if (Math.abs(rawX + newW - other.x) < SNAP_TOLERANCE) snapX = other.x - newW;
        if (Math.abs(rawX - (other.x + other.w)) < SNAP_TOLERANCE) snapX = other.x + other.w;

        if (Math.abs(rawY - other.y) < SNAP_TOLERANCE) snapY = other.y;
        if (Math.abs(rawY + newH - other.y) < SNAP_TOLERANCE) snapY = other.y - newH;
        if (Math.abs(rawY - (other.y + other.h)) < SNAP_TOLERANCE) snapY = other.y + other.h;
      }

      r.x = snapX;
      r.y = snapY;
      r.w = newW;
      r.h = newH;
      r.adv = r.w;
    } else if (resizeMode) {
      r.w = Math.max(1, mouseX - r.x);
      r.h = Math.max(1, mouseY - r.y);

      // 同步更新 adv 和 xoff，讓藍框也跟著拉伸
      r.adv = r.w;
      r.xoff = 0; // 讓偏移回歸起點（藍框左邊對齊格子起點）
      
      // r.xoff = Math.floor((r.adv - r.w) / 2);
} else {
      let newX = mouseX - dragOffsetX;
      let newY = mouseY - dragOffsetY;
      let snapX = newX;
      let snapY = newY;

      for (let i = 0; i < rects.length; i++) {
        if (i === dragIndex) continue;
        const other = rects[i];

        if (Math.abs(newX - other.x) < SNAP_TOLERANCE) snapX = other.x;
        if (Math.abs(newX - (other.x + other.w)) < SNAP_TOLERANCE) snapX = other.x + other.w;
        if (Math.abs(newX + r.w - other.x) < SNAP_TOLERANCE) snapX = other.x - r.w;

        if (Math.abs(newY - other.y) < SNAP_TOLERANCE) snapY = other.y;
        if (Math.abs(newY - (other.y + other.h)) < SNAP_TOLERANCE) snapY = other.y + other.h;
        if (Math.abs(newY + r.h - other.y) < SNAP_TOLERANCE) snapY = other.y - r.h;
      }

      r.x = snapX;
      r.y = snapY;
    }

    drawAllRects();
  }

  let hoverResize = false;
  for (let i = 0; i < rects.length; i++) {
    const r = rects[i];
    const rx = r.x + r.w;
    const ry = r.y + r.h;
    if (
      mouseX >= rx - RESIZE_HITBOX &&
      mouseX <= rx &&
      mouseY >= ry - RESIZE_HITBOX &&
      mouseY <= ry
    ) {
      hoverResize = true;
      break;
    }
  }
  canvas.style.cursor = hoverResize ? "nwse-resize" : "default";
});


canvas.addEventListener("mouseup", () => {
  if (creatingNewRect) {
    const r = rects[rects.length - 1];
    if (r.w < 4 || r.h < 4) {
      rects.pop(); // 刪除太小的格子
    }
  }
  dragIndex = -1;
  resizeMode = false;
  creatingNewRect = false;
  updateCharEditor();
  drawAllRects();
});

canvas.addEventListener("mouseleave", () => dragIndex = -1);

function drawAllRects() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (image.src) ctx.drawImage(image, 0, 0);


    // 顯示選取中的格子編號
    rects.forEach((r, i) => {
  ctx.strokeStyle = "gold";
  ctx.strokeRect(r.x, r.y, r.w, r.h);

  // 每格都標編號（黑色）
  //ctx.fillStyle = "black";
  //ctx.font = "12px sans-serif";
  //ctx.fillText(`#${i}`, r.x + 2, r.y + 14);

  // 選中的格子用紅底框標示編號
  if (i === selectedIndex) {
      const label = `#${i}`;
      ctx.font = "bold 14px sans-serif";
      const textWidth = ctx.measureText(label).width;
      const textX = r.x + 2;
      const textY = r.y + 16;

      // 紅色底
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      ctx.fillRect(textX - 2, textY - 12, textWidth + 4, 16);

      // 白字
      ctx.fillStyle = "rgba(255, 255, 255, 1)";
      ctx.fillText(label, textX, textY);
}

  // 水平偏移線：左（藍色）
  ctx.strokeStyle = "lightblue";
  ctx.beginPath();
  ctx.moveTo(r.x + r.xoff, r.y);
  ctx.lineTo(r.x + r.xoff, r.y + r.h);
  ctx.stroke();

  // 水平偏移線：右（yoff）
    ctx.beginPath();
    ctx.moveTo(r.x + r.xoff + r.adv, r.y);
    ctx.lineTo(r.x + r.xoff + r.adv, r.y + r.h);
    ctx.stroke();

  // 垂直偏移線（yoff）
    ctx.beginPath();
    ctx.moveTo(r.x, r.y + r.yoff);
    ctx.lineTo(r.x + r.w, r.y + r.yoff);
    ctx.stroke();
  });
  drawPreviewString();
}

function clearAllRects() {
  if (confirm("確定要清除所有裁切格子嗎？")) {
    rects = [];
    selectedIndex = -1;
    updateCharEditor();
    drawAllRects();
  }
}

function drawPreviewString() {
  const str = document.getElementById("previewString").value;
  const canvas2 = document.getElementById("stringPreview");
  const ctx2 = canvas2.getContext("2d");
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

  const lines = str.split("\n");
  const maxHeight = Math.max(...rects.map(r => r.h)) || 1;
  const lineHeight = maxHeight + 10;

  // 計算總高度、總寬度
  let maxLineWidth = 0;
  for (let line of lines) {
    let lineWidth = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      lineWidth += r.adv || r.w;
    }
    if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
  }
  const totalHeight = lineHeight * lines.length;

  // 按照比例縮放
  const scaleX = canvas2.width / maxLineWidth;
  const scaleY = canvas2.height / totalHeight;
  const scale = Math.min(scaleX, scaleY, 1);

  let yBase = 0;
  for (let line of lines) {
    let x = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      const drawX = x + (r.xoff || 0) * scale;
      const drawY = yBase + (r.yoff || 0) * scale;
      ctx2.drawImage(image, r.x, r.y, r.w, r.h, drawX, drawY, r.w * scale, r.h * scale);
      x += (r.adv || r.w) * scale;
    }
    yBase += lineHeight * scale;
  }
}
  

function updateGridSizeFromCount() {
  const cols = parseInt(document.getElementById("gridCols").value);
  const rows = parseInt(document.getElementById("gridRows").value);
  const MAX_CELLS = 50;

  if (isNaN(cols) || isNaN(rows) || cols <= 0 || rows <= 0) {
    alert("請輸入有效的欄數與列數");
    return;
  }

  if (cols * rows > MAX_CELLS) {
    alert(`格子總數 (${cols * rows}) 超過上限 ${MAX_CELLS}，請減少欄數或列數`);
    return;
  }

  const w = Math.floor(canvas.width / cols);
  const h = Math.floor(canvas.height / rows);
  document.getElementById("gridW").value = w;
  document.getElementById("gridH").value = h;

  autoSlice(true);
}


function autoSlice(clearOld = true) {
  const w = parseInt(document.getElementById("gridW").value);
  const h = parseInt(document.getElementById("gridH").value);
  const cols = Math.floor(canvas.width / w);
  const rows = Math.floor(canvas.height / h);
  if (clearOld) rects = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      rects.push({ x: x * w, y: y * h, w: w, h: h, adv: w, xoff: 0, yoff: 0 });
    }
  }
  updateCharEditor();
  drawAllRects();
}

function addManualRect() {
  rects.push({ x: 0, y: 0, w: 32, h: 32, adv: 32, xoff: 0, yoff: 0 });
  updateCharEditor();
  drawAllRects();
}

function updateCharEditor() {
  const container = document.getElementById("charEditor");
  const label = document.getElementById("currentEditLabel");
  container.innerHTML = "";

  if (selectedIndex >= 0 && rects[selectedIndex]) {
    label.textContent = `🔧 正在編輯格子 #${selectedIndex}`;
  } else {
    label.textContent = "";
  }

  rects.forEach((r, i) => {
    const row = document.createElement("div");
    row.className = "char-row" + (i === selectedIndex ? " highlight" : "");
    row.id = `charRow_${i}`;
    row.innerHTML = `
      #${i}
      x:<input id="x_input_${i}" type="number" value="${r.x}" 
         oninput="updateVal(${i}), 'x', this.value)" style="width:60px;">

      y:<input id="y_input_${i}" type="number" value="${r.y}" 
         oninput="updateVal(${i}), 'y', this.value)" style="width:60px;">

      寬『橘框』:<input id="w_input_${i}" type="number" value="${r.w}" oninput="updateVal(${i}), 'w', this.value)" style="width:60px;">

      高:<input id="h_input_${i}" type="number" value="${r.h}" oninput="updateVal(${i}), 'h', this.value)" style="width:60px;">

      字元寬度『藍框』:<input id="adv_input_${i}" type="number" value="${r.adv}" 
  oninput="updateVal(${i}), 'adv', this.value)" style="width:60px;">


      <button onclick="confirmAdv(${i})">確認</button>
      <button onclick="removeRect(${i})" style="color:red;">❌</button>
      <span class="advanced-toggle" onclick="toggleAdvanced(${i})">進階設定 ▼</span>
      <div class="advanced-section" id="adv_section_${i}">
        水平偏移:<input id="xoff_input_${i}" type="number" value="${r.xoff}" 
        oninput="updateVal(${i}), 'xoff', this.value)" style="width:60px;">
        垂直偏移:<input id="yoff_input_${i}" type="number" value="${r.yoff}" 
        oninput="updateVal(${i}), 'yoff', this.value)" style="width:60px;">

        <button onclick="confirmOffset(${i})">確認位移</button>
      </div>
    `;
    container.appendChild(row);
  });
}

function setSelected(i) {
  if (selectedIndex === i) return; // 若已選中就不動作
  selectedIndex = i;
  drawAllRects();

  // 只更新高亮，不呼叫 updateCharEditor
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });
}


function removeRect(index) {
  rects.splice(index, 1);
  updateCharEditor();
  drawAllRects();
}

function toggleAdvanced(i) {
  const sec = document.getElementById(`adv_section_${i}`);
  sec.style.display = sec.style.display === 'block' ? 'none' : 'block';
}

function updateVal(i, prop, val) {
  rects[i][prop] = parseInt(val);
  selectedIndex = i;
  drawAllRects();

  // 更新 highlight 樣式
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });

  // 自動捲動到對應項目（避免輸入時不知道對應哪格）
  const el = document.getElementById(`charRow_${selectedIndex}`);
  if (el) {
    el.scrollIntoView({ behavior: "smooth", block: "center" });
  }

  // 延遲整體更新，防止 lag
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    updateCharEditor();
  }, 200);
}

function confirmAdv(i) {
  const rect = rects[i];
  const get = id => parseFloat(document.getElementById(`${id}_input_${i}`).value);

  const x = get("x");
  const y = get("y");
  const w = get("w");
  const h = get("h");
  const adv = get("adv");

  if (!isNaN(x)) rect.x = x;
  if (!isNaN(y)) rect.y = y;
  if (!isNaN(w)) rect.w = w;
  if (!isNaN(h)) rect.h = h;
  if (!isNaN(adv)) rect.adv = adv;

  drawAllRects();
}


function confirmOffset(i) {
  const xoff = parseInt(document.getElementById(`xoff_input_${i}`).value);
  const yoff = parseInt(document.getElementById(`yoff_input_${i}`).value);
  if (!isNaN(xoff)) rects[i].xoff = xoff;
  if (!isNaN(yoff)) rects[i].yoff = yoff;
  drawAllRects();
}

function centerAllOffsets() {
  const lineHeight = Math.max(...rects.map(r => r.h));
  rects.forEach((r) => {
    r.xoff = Math.floor((r.adv - r.w) / 2);
    r.yoff = Math.floor((lineHeight - r.h) / 2);
  });
  updateCharEditor();
  drawAllRects();
}

function generateFNT() {
  const chars = document.getElementById("charList").value;
  const lineHeight = Math.max(...rects.map(r => r.h));
  const base = lineHeight - 5;
  const fnt = [];
  fnt.push(`info face="bitmap" size=${lineHeight} bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1`);
  fnt.push(`common lineHeight=${lineHeight} base=${base} scaleW=${canvas.width} scaleH=${canvas.height} pages=1 packed=0`);
  fnt.push(`page id=0 file="${imageFilename}"`);
  fnt.push("chars count=" + chars.length);
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const id = c.charCodeAt(0);
    const xoff = r.xoff < 0 ? 0 : r.xoff;
    const yoff = r.yoff < 0 ? 0 : r.yoff;
    fnt.push(`char id=${id} x=${r.x} y=${r.y} width=${r.w} height=${r.h} xoffset=${xoff} yoffset=${yoff} xadvance=${r.adv} page=0 chnl=0`);
  });
  document.getElementById("outputFNT").value = fnt.join("\n");
}

function downloadFNT() {
  const blob = new Blob([document.getElementById("outputFNT").value], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".fnt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function downloadPlist() {
  const chars = document.getElementById("charList").value;
  const frames = {};
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const name = `${getSafeCharName(c)}.png`;
    frames[name] = {
      frame: `{{${r.x},${r.y}},{${r.w},${r.h}}}`,
      offset: `{0,0}`,
      rotated: false,
      sourceColorRect: `{{0,0},{${r.w},${r.h}}}`,
      sourceSize: `{${r.w},${r.h}}`
    };
  });

  const plistObj = {
    frames: frames,
    metadata: {
      format: 2,
      realTextureFileName: imageFilename,
      size: `{${canvas.width},${canvas.height}}`,
      smartupdate: "$TexturePacker:SmartUpdate$",
      textureFileName: imageFilename
    }
  };

  const content = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>frames</key>
  <dict>
${Object.entries(plistObj.frames).map(([name, f]) => `
    <key>${name}</key>
    <dict>
      <key>frame</key><string>${f.frame}</string>
      <key>offset</key><string>${f.offset}</string>
      <key>rotated</key><false/>
      <key>sourceColorRect</key><string>${f.sourceColorRect}</string>
      <key>sourceSize</key><string>${f.sourceSize}</string>
    </dict>`).join("\n")}
  </dict>
  <key>metadata</key>
  <dict>
    <key>format</key><integer>${plistObj.metadata.format}</integer>
    <key>realTextureFileName</key><string>${plistObj.metadata.realTextureFileName}</string>
    <key>size</key><string>${plistObj.metadata.size}</string>
    <key>smartupdate</key><string>${plistObj.metadata.smartupdate}</string>
    <key>textureFileName</key><string>${plistObj.metadata.textureFileName}</string>
  </dict>
</dict>
</plist>`;

  const blob = new Blob([content], { type: "text/xml" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".plist";
  a.click();
  URL.revokeObjectURL(a.href);
}

function getSafeCharName(c) {
  const map = {
    ",": "Comma",
    ".": "decimal",
    ":": "Colon",
    ";": "Semicolon",
    "+": "Plus",
    "-": "Minus",
    "/": "Slash",
    "!": "Exclamation",
    "?": "Question",
    "*": "Asterisk",
    " ": "Space",
    "\"": "Quote",
    "'": "Apostrophe",
    "\\": "Backslash",
    "|": "Pipe",
    "<": "LessThan",
    ">": "GreaterThan",
    "[": "LBracket",
    "]": "RBracket",
    "(": "LParen",
    ")": "RParen",
    "#": "Hash",
    "&": "Ampersand",
    "%": "Percent",
    "=": "Equal",
    "x": "x",
    "$": "Money"

  };

  // 若是 a~z 或 A~Z 或 數字，直接保留
  if (/^[a-zA-Z0-9]$/.test(c)) return c;
  return map[c] || `U${c.charCodeAt(0)}`; // fallback：以 Unicode 命名
}



document.getElementById("imageUpload").addEventListener("change", e => {
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = evt => {
    image.onload = () => {
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      drawAllRects();
    };
    image.src = evt.target.result;
    imageFilename = file.name;
  };
  reader.readAsDataURL(file);
});
</script>
</body>
</html>
