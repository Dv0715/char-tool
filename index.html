 <!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8"/>
<title>åœ–å­—è£½ä½œå°å·¥å…·</title>
<style>
  body {
    background-color: #fff;
    font-family: 'Segoe UI', sans-serif;
    color: #333;
  }
  canvas {
    border: 1px solid #aaa;
    background-color: #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    display: block;
    margin-bottom: 10px;
    border-radius: 4px;
    cursor: default;
    transform-origin: top left;
  }
  /* åªé‡å°ç¸®æ”¾æŒ‰éˆ•è¨­å®šçµ±ä¸€é«˜åº¦ */
  #zoom2Btn, #resetZoomBtn {
    height: 22px;
    line-height: 22px;
    padding: 0 12px;
    font-size: 14px;
  }
.toolbar {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 10px;
}

.toolbar-label {
  white-space: nowrap;
}



  .char-row { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; flex-wrap: wrap; }
  textarea { width: 100%; height: 150px; margin-top: 20px; }
  .advanced-toggle { cursor: pointer; color: #007bff; text-decoration: underline; margin-left: 10px; }
  .advanced-section { display: none; margin-top: 5px; }
  .highlight { color: #b22222; }
</style>
</head>
<body>
<h2>ğŸ§© åœ–å­—è£½ä½œå°å·¥å…·(By:å°D)</h2>
<input accept="image/*" id="imageUpload" type="file"/><br/><br/>

æ ¼å¯¬ <input id="gridW" style="width:60px;" type="number" value="40"/>
æ ¼é«˜ <input id="gridH" style="width:60px;" type="number" value="60"/>
ï½œæˆ–ä¾æ ¼æ•¸åˆ‡ï¼š
æ¬„æ•¸ <input id="gridCols" style="width:60px;" type="number" placeholder="æ¬„æ•¸" onchange="updateGridSizeFromCount()"/>
åˆ—æ•¸ <input id="gridRows" style="width:60px;" type="number" placeholder="åˆ—æ•¸" onchange="updateGridSizeFromCount()"/>

<button onclick="autoSlice(true)">è£½ä½œè£åˆ‡</button>
<button onclick="clearAllRects()">æ¸…é™¤è£åˆ‡</button>
<button onclick="centerAllOffsets()">ğŸ“Œ å±…ä¸­ã€ä¿®æ”¹å­—å…ƒå¯¬åº¦å¾Œè¦é»é€™è£¡é‡æ–°æ‰¾ä¸­å¿ƒé»ã€‘</button><span style="font-size: 14px; color: #999;">ï¼ˆâš ï¸ æŒ‰ä¸‹å¾Œæœƒè¦†è“‹æ‰€æœ‰æ‰‹å‹•åç§»ï¼‰</span><br/>

  <!-- æ–°å¢å€ç‡é¸æ“‡ -->
  <label for="zoomSelect" class="toolbar-label">å€ç‡ï¼š</label>
  <select id="zoomSelect" onchange="setZoom(Number(this.value))">
    <option value="1">x1</option>
    <option value="2">x2</option>
    <option value="3">x3</option>
  </select>
<br/>

å­—å…ƒé †åºï¼š<input id="charList" type="text" value="0123456789,."/><br/>

<!-- 
<button id="zoom2Btn">X2</button>
<button id="resetZoomBtn">é‚„åŸ</button>
-->

<canvas id="preview" width="512" height="128"></canvas>
<div id="currentEditLabel" style="font-weight:bold; margin-bottom:5px; color:#555;"></div>
<div id="charEditor"></div>
<span style="font-size: 16px; color: #666;">ï¼ˆå»ºè­°å¯¬æ•¸å€¼å„˜é‡èˆ‡å­—å…ƒå¯¬åº¦ç›¸åŒ,æ‰ä¸å®¹æ˜“å‡ºéŒ¯ï¼‰</span><br/>
<button onclick="addManualRect()">â• æ‰‹å‹•æ–°å¢æ ¼</button><br/>
é è¦½å­—ä¸²ï¼š<textarea id="previewString" style="width: 300px; height: 40px;" oninput="drawPreviewString()">123.45,678.9</textarea><br/>
<canvas id="stringPreview" width="512" height="210" style="border:1px solid #aaa; margin-top:10px;"></canvas>
<br/>
<button onclick="generateFNT()">ç”¢ç”Ÿ .fnt</button>
<button onclick="downloadFNT()">ä¸‹è¼‰ .fnt</button><span style="font-size: 16px; color: #666;">ï¼ˆä¸‹è¼‰.fntå‰ä¸€å®šè¦å…ˆé»é¸ã€ç”¢ç”Ÿ.fntã€æŒ‰éˆ•ï¼‰</span>
<span style="float: right;"><button onclick="downloadPlist()">ä¸‹è¼‰ .plist(éœ€è£½ä½œåœ–é›†æ™‚ä½¿ç”¨)</button></span>
<textarea id="outputFNT"></textarea>
<div style="margin-top: 10px;"><span style="font-size: 16px; color: #666;">â—†æ›´æ–°æ—¥èªŒ:</span><br/>
<span style="font-size: 16px; color: #666;">25/7/4 å¢åŠ ç”¢ç”Ÿ.fntæª”æç¤ºã€å¢åŠ å±…ä¸­éˆ•æç¤º</span><br/>
<span style="font-size: 16px; color: #666;">25/7/14 è£åˆ‡å€åŸŸæ–°å¢èª¿æ•´å€ç‡æ¨¡å¼</span><br/>
</div>

<script>
const canvas = document.getElementById("preview");
const ctx = canvas.getContext("2d");
let image = new Image();
let imageFilename = "image.png";
let rects = [];
let dragIndex = -1, dragOffsetX = 0, dragOffsetY = 0;
let resizeMode = false, creatingNewRect = false;
let startX = 0, startY = 0, selectedIndex = -1;
let debounceTimer, zoomLevel = 1;
const SCREEN_SNAP = 8, RESIZE_HITBOX = 10;

// Zoom buttons
const zoomSelect = document.getElementById('zoomSelect');
zoomSelect.addEventListener('change', () => setZoom(Number(zoomSelect.value)));
function setZoom(level) {
  zoomLevel = level;

  if (level === 1) {
    canvas.style.transform = 'none';
    canvas.style.marginBottom = '';      // é‚„åŸ
  } else {
    canvas.style.transform = `scale(${level})`;
    // å¤šç•™å‡º (scale - 1) * canvas åŸå§‹é«˜åº¦ ä½œç‚ºä¸‹æ–¹é–“è·
    canvas.style.marginBottom = `${(canvas.height * (level - 1))}px`;
  }
}

// Unified mouse handlers
canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / zoomLevel;
  const y = (e.clientY - rect.top) / zoomLevel;
  dragIndex = rects.findIndex(r => x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h);
  selectedIndex = dragIndex;
  if (dragIndex>=0) {
    const r = rects[dragIndex];
    if (x>=r.x+r.w-RESIZE_HITBOX&&x<=r.x+r.w&&y>=r.y+r.h-RESIZE_HITBOX&&y<=r.y+r.h) {
      resizeMode = true;
    } else {
      resizeMode = false;
      dragOffsetX = x - r.x;
      dragOffsetY = y - r.y;
    }
  } else {
    creatingNewRect = true; startX = x; startY = y;
    rects.push({x,y,w:1,h:1,adv:1,xoff:0,yoff:0});
    dragIndex = rects.length-1;
  }
});
canvas.addEventListener("mousemove", (e) => {
  // 1. æ¯æ¬¡æ»‘é¼ ç§»å‹•æ™‚è¨ˆç®—ã€Œç•«é¢ä¸Š8pxã€åœ¨ canvas åº§æ¨™ç³»çš„è·é›¢
  const tol = SCREEN_SNAP / zoomLevel;  

  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / zoomLevel;
  const my = (e.clientY - rect.top) / zoomLevel;

  if (dragIndex !== -1) {
    const r = rects[dragIndex];

    if (creatingNewRect) {
      // ... è¨ˆç®— rawX, rawY, newW, newH ...
      let rawX = Math.min(startX, mx);
      let rawY = Math.min(startY, my);
      let newW  = Math.max(1, Math.abs(mx - startX));
      let newH  = Math.max(1, Math.abs(my - startY));

      // åˆå§‹ snap å€¼
      let snapX = rawX, snapY = rawY;
      let snapW = newW, snapH = newH;

      // 2. æŠŠé€™è£¡æ‰€æœ‰ < SNAP_TOLERANCE æ”¹æˆ < tol
      for (let i = 0; i < rects.length - 1; i++) {
        const o = rects[i];
        // å·¦é‚Šå°é½Š
        if (Math.abs(rawX - o.x)             < tol) snapX = o.x;
        // å³é‚Šå°é½Š â†’ åŒæ™‚å½±éŸ¿å¯¬åº¦
        if (Math.abs(rawX + newW - o.x)      < tol) snapW = o.x - snapX;
        if (Math.abs(rawX + newW - (o.x+o.w))< tol) snapW = o.x+o.w - snapX;

        // ä¸Šé‚Šå°é½Š
        if (Math.abs(rawY - o.y)             < tol) snapY = o.y;
        // ä¸‹é‚Šå°é½Š â†’ åŒæ™‚å½±éŸ¿é«˜åº¦
        if (Math.abs(rawY + newH - o.y)      < tol) snapH = o.y - snapY;
        if (Math.abs(rawY + newH - (o.y+o.h))< tol) snapH = o.y+o.h - snapY;
      }

      // å¯¦éš›å¥—ç”¨
      r.x = snapX;
      r.y = snapY;
      r.w = snapW;
      r.h = snapH;
      r.adv = snapW;
    }
   else if (resizeMode) {
     // ã€Œæ‹‰ä¼¸ï¼‹å¸é™„ã€
     let newW = Math.max(1, (e.clientX - canvas.getBoundingClientRect().left)/zoomLevel - r.x);
     let newH = Math.max(1, (e.clientY - canvas.getBoundingClientRect().top)/zoomLevel  - r.y);
     let snapW = newW, snapH = newH;
     rects.forEach((o, i) => {
       if (i === dragIndex) return;
       // æ©«å‘å¸é™„
       if (Math.abs(r.x + newW - o.x)       < tol) snapW = o.x - r.x;
       if (Math.abs(r.x + newW - (o.x+o.w)) < tol) snapW = o.x+o.w - r.x;
       // ç¸±å‘å¸é™„
       if (Math.abs(r.y + newH - o.y)       < tol) snapH = o.y - r.y;
       if (Math.abs(r.y + newH - (o.y+o.h)) < tol) snapH = o.y+o.h - r.y;
     });
     r.w = snapW; r.h = snapH;
     r.adv = snapW; r.xoff = 0;
   }
    else {
      // ã€Œæ‹–æ›³ï¼‹å¸é™„ã€
      let newX = mx - dragOffsetX;
      let newY = my - dragOffsetY;
      let snapX = newX, snapY = newY;
      rects.forEach((o, i) => {
        if (i === dragIndex) return;
        // å·¦ï¼å³é‚Šå¸é™„
        if (Math.abs(newX       - o.x       ) < tol) snapX = o.x;
        if (Math.abs(newX + r.w - o.x       ) < tol) snapX = o.x - r.w;
        if (Math.abs(newX       - (o.x+o.w) ) < tol) snapX = o.x+o.w;
        // ä¸Šï¼ä¸‹é‚Šå¸é™„
        if (Math.abs(newY       - o.y       ) < tol) snapY = o.y;
        if (Math.abs(newY + r.h - o.y       ) < tol) snapY = o.y - r.h;
        if (Math.abs(newY       - (o.y+o.h) ) < tol) snapY = o.y+o.h;
      });
      r.x = snapX; r.y = snapY;
    }

    drawAllRects();
  }
  // cursor style
  let hit = false;
  rects.forEach(r => {
    if (mx>=r.x+r.w-RESIZE_HITBOX&&mx<=r.x+r.w&&my>=r.y+r.h-RESIZE_HITBOX&&my<=r.y+r.h) hit=true;
  });
  canvas.style.cursor = hit? 'nwse-resize':'default';
});
canvas.addEventListener("mouseup", () => {
  if (creatingNewRect) {
    const r = rects[rects.length-1];
    if (r.w<4||r.h<4) rects.pop();
  }
  dragIndex=-1; resizeMode=false; creatingNewRect=false;
  updateCharEditor(); drawAllRects();
});
canvas.addEventListener("mouseleave", () => dragIndex=-1);

function drawAllRects() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (image.src) ctx.drawImage(image,0,0);

//é¡¯ç¤ºé¸å–ä¸­çš„æ ¼å­ç·¨è™Ÿ
  rects.forEach((r,i) => {
    ctx.strokeStyle="gold"; ctx.strokeRect(r.x,r.y,r.w,r.h);

// é¸ä¸­çš„æ ¼å­ç”¨ç´…åº•æ¡†æ¨™ç¤ºç·¨è™Ÿ
    if (i===selectedIndex) {
      const lbl=`#${i}`;
      ctx.font="bold 14px sans-serif";
      ctx.textBaseline = "top";

  // 2. é‡æ–‡å­—å¯¬ã€é«˜
      const tw=ctx.measureText(lbl).width;
  const th = 14;            // èˆ‡å­—å‹å¤§å°ç›¸åŒ
  const margin = 4;         // Canvas åº§æ¨™ä¸‹çš„å…§é‚Šè·


// ç´…åº•æ¨™ç±¤å…§ç¸®åƒæ•¸ï¼ˆç•«å¸ƒåº§æ¨™ï¼‰
const padding = 2;

// 1) èƒŒæ™¯
ctx.fillStyle = "rgba(255,0,0,0.5)";
ctx.fillRect(
  r.x + padding,                 // å¾€å³è·‘ padding
  r.y + padding,                 // å¾€ä¸‹è·‘ padding
  tw + padding*2,                // å¯¬åº¦ + å·¦å³ padding
  14 + padding*2                 // æ–‡å­—é«˜åº¦ï¼ˆ14pxï¼‰+ ä¸Šä¸‹ padding
);

// 2) æ–‡å­—
ctx.fillStyle = "#fff";
ctx.textBaseline = "top";
ctx.fillText(
  lbl,
  r.x + padding,
  r.y + padding
);
}
    // æ°´å¹³åç§»ç·šï¼šå·¦ï¼ˆè—è‰²ï¼‰
    ctx.strokeStyle="lightblue";
    ctx.beginPath(); ctx.moveTo(r.x+r.xoff,r.y);
    ctx.lineTo(r.x+r.xoff,r.y+r.h); ctx.stroke();

    // æ°´å¹³åç§»ç·šï¼šå³ï¼ˆyoffï¼‰
    ctx.beginPath(); ctx.moveTo(r.x+r.xoff+r.adv,r.y);
    ctx.lineTo(r.x+r.xoff+r.adv,r.y+r.h); ctx.stroke();

    // å‚ç›´åç§»ç·šï¼ˆyoffï¼‰
    ctx.beginPath(); ctx.moveTo(r.x,r.y+r.yoff);
    ctx.lineTo(r.x+r.w,r.y+r.yoff); ctx.stroke();
  });
  drawPreviewString();
}

function clearAllRects() {
  if (confirm("ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è£åˆ‡æ ¼å­å—ï¼Ÿ")) {
    rects = [];
    selectedIndex = -1;
    updateCharEditor();
    drawAllRects();
  }
}

function drawPreviewString() {
  const str = document.getElementById("previewString").value;
  const canvas2 = document.getElementById("stringPreview");
  const ctx2 = canvas2.getContext("2d");
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

  const lines = str.split("\n");
  const maxHeight = Math.max(...rects.map(r => r.h)) || 1;
  const lineHeight = maxHeight + 10;

  // è¨ˆç®—ç¸½é«˜åº¦ã€ç¸½å¯¬åº¦
  let maxLineWidth = 0;
  for (let line of lines) {
    let lineWidth = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      lineWidth += r.adv || r.w;
    }
    if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
  }
  const totalHeight = lineHeight * lines.length;

  // æŒ‰ç…§æ¯”ä¾‹ç¸®æ”¾
  const scaleX = canvas2.width / maxLineWidth;
  const scaleY = canvas2.height / totalHeight;
  const scale = Math.min(scaleX, scaleY, 1);

  let yBase = 0;
  for (let line of lines) {
    let x = 0;
    for (let c of line) {
      const index = document.getElementById("charList").value.indexOf(c);
      const r = rects[index];
      if (!r) continue;
      const drawX = x + (r.xoff || 0) * scale;
      const drawY = yBase + (r.yoff || 0) * scale;
      ctx2.drawImage(image, r.x, r.y, r.w, r.h, drawX, drawY, r.w * scale, r.h * scale);
      x += (r.adv || r.w) * scale;
    }
    yBase += lineHeight * scale;
  }
}
  

function updateGridSizeFromCount() {
  const cols = parseInt(document.getElementById("gridCols").value);
  const rows = parseInt(document.getElementById("gridRows").value);
  const MAX_CELLS = 50;

  if (isNaN(cols) || isNaN(rows) || cols <= 0 || rows <= 0) {
    alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ¬„æ•¸èˆ‡åˆ—æ•¸");
    return;
  }

  if (cols * rows > MAX_CELLS) {
    alert(`æ ¼å­ç¸½æ•¸ (${cols * rows}) è¶…éä¸Šé™ ${MAX_CELLS}ï¼Œè«‹æ¸›å°‘æ¬„æ•¸æˆ–åˆ—æ•¸`);
    return;
  }

  const w = Math.floor(canvas.width / cols);
  const h = Math.floor(canvas.height / rows);
  document.getElementById("gridW").value = w;
  document.getElementById("gridH").value = h;

  autoSlice(true);
}


function autoSlice(clearOld = true) {
  const w = parseInt(document.getElementById("gridW").value);
  const h = parseInt(document.getElementById("gridH").value);
  const cols = Math.floor(canvas.width / w);
  const rows = Math.floor(canvas.height / h);
  if (clearOld) rects = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      rects.push({ x: x * w, y: y * h, w: w, h: h, adv: w, xoff: 0, yoff: 0 });
    }
  }
  updateCharEditor();
  drawAllRects();
}

function addManualRect() {
  rects.push({ x: 0, y: 0, w: 32, h: 32, adv: 32, xoff: 0, yoff: 0 });
  updateCharEditor();
  drawAllRects();
}

function updateCharEditor() {
  const container = document.getElementById("charEditor");
  const label = document.getElementById("currentEditLabel");
  container.innerHTML = "";

  if (selectedIndex >= 0 && rects[selectedIndex]) {
    label.textContent = `ğŸ”§ æ­£åœ¨ç·¨è¼¯æ ¼å­ #${selectedIndex}`;
  } else {
    label.textContent = "";
  }

  rects.forEach((r, i) => {
    const row = document.createElement("div");
    row.className = "char-row" + (i === selectedIndex ? " highlight" : "");
    row.id = `charRow_${i}`;
    row.innerHTML = `
      #${i}
      x:<input id="x_input_${i}" type="number" value="${r.x}" 
         oninput="updateVal(${i}), 'x', this.value)" style="width:60px;">

      y:<input id="y_input_${i}" type="number" value="${r.y}" 
         oninput="updateVal(${i}), 'y', this.value)" style="width:60px;">

      å¯¬ã€æ©˜æ¡†ã€:<input id="w_input_${i}" type="number" value="${r.w}" oninput="updateVal(${i}), 'w', this.value)" style="width:60px;">

      é«˜:<input id="h_input_${i}" type="number" value="${r.h}" oninput="updateVal(${i}), 'h', this.value)" style="width:60px;">

      å­—å…ƒå¯¬åº¦ã€è—æ¡†ã€:<input id="adv_input_${i}" type="number" value="${r.adv}" 
  oninput="updateVal(${i}), 'adv', this.value)" style="width:60px;">


      <button onclick="confirmAdv(${i})">ç¢ºèª</button>
      <button onclick="removeRect(${i})" style="color:red;">âŒ</button>
      <span class="advanced-toggle" onclick="toggleAdvanced(${i})">é€²éšè¨­å®š â–¼</span>
      <div class="advanced-section" id="adv_section_${i}">
        æ°´å¹³åç§»:<input id="xoff_input_${i}" type="number" value="${r.xoff}" 
        oninput="updateVal(${i}), 'xoff', this.value)" style="width:60px;">
        å‚ç›´åç§»:<input id="yoff_input_${i}" type="number" value="${r.yoff}" 
        oninput="updateVal(${i}), 'yoff', this.value)" style="width:60px;">

        <button onclick="confirmOffset(${i})">ç¢ºèªä½ç§»</button>
      </div>
    `;
    container.appendChild(row);
  });
}

function setSelected(i) {
  if (selectedIndex === i) return; // è‹¥å·²é¸ä¸­å°±ä¸å‹•ä½œ
  selectedIndex = i;
  drawAllRects();

  // åªæ›´æ–°é«˜äº®ï¼Œä¸å‘¼å« updateCharEditor
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });
}


function removeRect(index) {
  rects.splice(index, 1);
  updateCharEditor();
  drawAllRects();
}

function toggleAdvanced(i) {
  const sec = document.getElementById(`adv_section_${i}`);
  sec.style.display = sec.style.display === 'block' ? 'none' : 'block';
}

function updateVal(i, prop, val) {
  rects[i][prop] = parseInt(val);
  selectedIndex = i;
  drawAllRects();

  // æ›´æ–° highlight æ¨£å¼
  const allRows = document.querySelectorAll(".char-row");
  allRows.forEach((row, idx) => {
    if (idx === selectedIndex) {
      row.classList.add("highlight");
    } else {
      row.classList.remove("highlight");
    }
  });

  // è‡ªå‹•æ²å‹•åˆ°å°æ‡‰é …ç›®ï¼ˆé¿å…è¼¸å…¥æ™‚ä¸çŸ¥é“å°æ‡‰å“ªæ ¼ï¼‰
  const el = document.getElementById(`charRow_${selectedIndex}`);
  if (el) {
    el.scrollIntoView({ behavior: "smooth", block: "center" });
  }

  // å»¶é²æ•´é«”æ›´æ–°ï¼Œé˜²æ­¢ lag
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    updateCharEditor();
  }, 200);
}

function confirmAdv(i) {
  const rect = rects[i];
  const get = id => parseFloat(document.getElementById(`${id}_input_${i}`).value);

  const x = get("x");
  const y = get("y");
  const w = get("w");
  const h = get("h");
  const adv = get("adv");

  if (!isNaN(x)) rect.x = x;
  if (!isNaN(y)) rect.y = y;
  if (!isNaN(w)) rect.w = w;
  if (!isNaN(h)) rect.h = h;
  if (!isNaN(adv)) rect.adv = adv;

  drawAllRects();
}


function confirmOffset(i) {
  const xoff = parseInt(document.getElementById(`xoff_input_${i}`).value);
  const yoff = parseInt(document.getElementById(`yoff_input_${i}`).value);
  if (!isNaN(xoff)) rects[i].xoff = xoff;
  if (!isNaN(yoff)) rects[i].yoff = yoff;
  drawAllRects();
}

function centerAllOffsets() {
  const lineHeight = Math.max(...rects.map(r => r.h));
  rects.forEach((r) => {
    r.xoff = Math.floor((r.adv - r.w) / 2);
    r.yoff = Math.floor((lineHeight - r.h) / 2);
  });
  updateCharEditor();
  drawAllRects();
}

function generateFNT() {
  const chars = document.getElementById("charList").value;
  const lineHeight = Math.max(...rects.map(r => r.h));
  const base = lineHeight - 5;
  const fnt = [];
  fnt.push(`info face="bitmap" size=${lineHeight} bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1`);
  fnt.push(`common lineHeight=${lineHeight} base=${base} scaleW=${canvas.width} scaleH=${canvas.height} pages=1 packed=0`);
  fnt.push(`page id=0 file="${imageFilename}"`);
  fnt.push("chars count=" + chars.length);
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const id = c.charCodeAt(0);
    const xoff = r.xoff < 0 ? 0 : r.xoff;
    const yoff = r.yoff < 0 ? 0 : r.yoff;
    fnt.push(`char id=${id} x=${r.x} y=${r.y} width=${r.w} height=${r.h} xoffset=${xoff} yoffset=${yoff} xadvance=${r.adv} page=0 chnl=0`);
  });
  document.getElementById("outputFNT").value = fnt.join("\n");
}

function downloadFNT() {
  const blob = new Blob([document.getElementById("outputFNT").value], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".fnt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function downloadPlist() {
  const chars = document.getElementById("charList").value;
  const frames = {};
  chars.split("").forEach((c, i) => {
    const r = rects[i];
    if (!r) return;
    const name = `${getSafeCharName(c)}.png`;
    frames[name] = {
      frame: `{{${r.x},${r.y}},{${r.w},${r.h}}}`,
      offset: `{0,0}`,
      rotated: false,
      sourceColorRect: `{{0,0},{${r.w},${r.h}}}`,
      sourceSize: `{${r.w},${r.h}}`
    };
  });

  const plistObj = {
    frames: frames,
    metadata: {
      format: 2,
      realTextureFileName: imageFilename,
      size: `{${canvas.width},${canvas.height}}`,
      smartupdate: "$TexturePacker:SmartUpdate$",
      textureFileName: imageFilename
    }
  };

  const content = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" 
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>frames</key>
  <dict>
${Object.entries(plistObj.frames).map(([name, f]) => `
    <key>${name}</key>
    <dict>
      <key>frame</key><string>${f.frame}</string>
      <key>offset</key><string>${f.offset}</string>
      <key>rotated</key><false/>
      <key>sourceColorRect</key><string>${f.sourceColorRect}</string>
      <key>sourceSize</key><string>${f.sourceSize}</string>
    </dict>`).join("\n")}
  </dict>
  <key>metadata</key>
  <dict>
    <key>format</key><integer>${plistObj.metadata.format}</integer>
    <key>realTextureFileName</key><string>${plistObj.metadata.realTextureFileName}</string>
    <key>size</key><string>${plistObj.metadata.size}</string>
    <key>smartupdate</key><string>${plistObj.metadata.smartupdate}</string>
    <key>textureFileName</key><string>${plistObj.metadata.textureFileName}</string>
  </dict>
</dict>
</plist>`;

  const blob = new Blob([content], { type: "text/xml" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = imageFilename.replace(/\.[^/.]+$/, "") + ".plist";
  a.click();
  URL.revokeObjectURL(a.href);
}

function getSafeCharName(c) {
  const map = {
    ",": "Comma",
    ".": "decimal",
    ":": "Colon",
    ";": "Semicolon",
    "+": "Plus",
    "-": "Minus",
    "/": "Slash",
    "!": "Exclamation",
    "?": "Question",
    "*": "Asterisk",
    " ": "Space",
    "\"": "Quote",
    "'": "Apostrophe",
    "\\": "Backslash",
    "|": "Pipe",
    "<": "LessThan",
    ">": "GreaterThan",
    "[": "LBracket",
    "]": "RBracket",
    "(": "LParen",
    ")": "RParen",
    "#": "Hash",
    "&": "Ampersand",
    "%": "Percent",
    "=": "Equal",
    "x": "x",
    "$": "Money"

  };

  // è‹¥æ˜¯ a~z æˆ– A~Z æˆ– æ•¸å­—ï¼Œç›´æ¥ä¿ç•™
  if (/^[a-zA-Z0-9]$/.test(c)) return c;
  return map[c] || `U${c.charCodeAt(0)}`; // fallbackï¼šä»¥ Unicode å‘½å
}



document.getElementById("imageUpload").addEventListener("change", e=>{
  const file=e.target.files[0];
  const reader=new FileReader();
  reader.onload=evt=>{ image.onload=()=>{ canvas.width=image.naturalWidth; canvas.height=image.naturalHeight; drawAllRects(); }; image.src=evt.target.result; imageFilename=file.name; };
  reader.readAsDataURL(file);
});
</script>
</body>
</html>
